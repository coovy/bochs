# os

<font size="2">&emsp;一直觉得计算机的世界，硬件就是树根，操作系统是个偌大的主干，网络是四周的枝干，其他的应用，ai之类都是繁茂的枝叶。</font>

<font size="2">&emsp;要在计算机领域走得更远，不懂操作系统这个怎么能行呢？我希望能有一天，自己更够构建出这个大树，从cpu->操作系统->编译器->连接器->加载器, 给后来人一份比较通畅的计算机体系架构知识参考实现, 但是这应该又永远不会实现，毕竟每一块的东西都太多了, 真正熟悉一个领域都很难。</font>  

<font size="2">&emsp;还是粗略记录一下系统实现的部分设计思路吧，形成这样的框架体系也不错，以后会抽时间重新总结一张思维大导图出来，绝不像一般大学课程中概述式的样子:</font>

<font size="2">&emsp;1978年6月8日intel发布第一款16位处理器: 8086, 有20根地址线, 所以2^20=1MB内存，这个时候下x86架构工作模式是实模式(尽管这是后来才有的命名), 它直接访问物理内存， 没有特权级，段基址随意修改，一次只能运行一个程序，内存只有1MB, 看一下这1MB的内存布局吧(p53):</font>

![实模式内存布局](records/实模式下的内存布局.png)

<font size="2">&emsp;这20根地址线，经过分配, 其中0\~0x9FFFF处是640KB的DRAM，就是咱们插上的内存条，0xF0000\~0xFFFFF这64KB是ROM, 里面存的是BIOS代码，中间是显存。中间还夹杂着一些可用区域。其中BIOS的工作是检测，初始化硬件，这是调用硬件本身提供的一些功能调用实现的，此外，它还建立了中断向量表，使得以后可以通过`int 中断号`实现相关硬件调用。</font>

<font size="2">&emsp;BIOS是计算机上运行的第一个软件，由硬件厂商写入顶端0xF0000\~0xFFFFF, 程序执行的入口地址便是0xFFFF0。一个16位的寄存器是访问不了20位的地址空间的,所以这个实模式下采用了**段基址: 段内偏移量**的组合，称为分段模式，将`段基址*16+段内偏移量`当作真正的地址。开机接电一瞬间, cpu的cs: ip寄存器被硬件初始化为`0xF000:0xFFF0`, 那么`0xF000*16+0xFFF0=0xFFFF0`, 这16B太小显然不可能是BIOS完全的代码, 实际上这里是一个跳转指令`jmp far f000:e05b`(书中写完mbr可以看到), 跳转到bios真正执行的地方, 然后检查内存，先科等信息， 再初始化硬件， 建立中断向量表*IVT*。(现在x64已经拥有了更强的启动方式，**UEFI**!!)。</font>

<font size="2">&emsp;BIOS最后的工作是检验启动盘(扇区末尾两字节是0x55和0xaa这两个魔数)0盘0道1扇区的内容(CHS表示硬盘扇区), BIOS最后的指令跳转到0x7c00(实模式内存布局中也可以看到这里是MBR被BIOS从磁盘中加载进来的位置), 至于为什么是0x7c00, 历史传承因素而已，是因为早期DOS1.0最小是32KB内存将MBR放到了最后1KB位置(`0x8000-0x400=0x7c00`), MBR的作用就是加载loader(内核加载器), 其实就是将loader文件从磁盘装进内存, 然后jmp到loader的地址。</font>

<font size="2">&emsp;然后是loader程序, 设定程序起始地址是`0x900`, 这是低30KB处的一段可用区域, 选取`0x900并没有特别的意思，仅仅是因为这段内存可用, 尽量从低地址写，留下一点栈空间，而已，这本书的作者喜欢整数，就选取了这个地址，这个loader程序不超过512B, 所以也占用一个扇区，它被MBR从磁盘加载进内存, 然后jmp过去。loader是内核加载程序，是用来加载内核程序的，内核程序有很多东西，有中断，内存管理系统，进程，线程管理，文件系统等等。这中间还有分页的概念，还有实模式很多没解决的问题，需要在loader中解决一些。准备进入32位保护模式</font>

<font size="2">&emsp;保护模式是32位的，用的32位寄存器，前面的mbr在实模式下用的只是这32位寄存器下的低16位。而且只用了部分寄存器，这样模拟的实模式环境。毕竟这本书写的是32位系统。1985年推出32位处理器80386，地址总线和寄存器都是32位，只不过还兼容之前的实模式。汇编中区分代码是在实模式还是保护模式其实就是一个指令: `[bits 32]`就是说下面的指令运行在保护模式，不写默认是`[bits 16]`，这是编译器实现的。但是作为loader怎么进入保护模式(从16位进入32位),其实就是1.打开A20(有根地址线控制着是否可以访问超过20根地址线的空间, 打开了就能访问高于20位地址空间了，不然就是回绕访问),2.加载gdt, cr0的pe位置1(crx是控制寄存器系列，这个位告诉cpu是什么模式) </font>

<font size="2">&emsp;保护模式是分段的，关于分段，一个重要的概念:*GDT(Global Descriptor Table)*全局描述符表, 它的地址被加载进GDTR寄存器:</font>
![gdtr](records/GDTR48位寄存器.png)

<font size="2">&emsp;全局描述符表中存储着**连续的32位**的段描述符, 它描述着每个段的信息, 看起来很乱？是为了兼容之前的16位cpu产品: 
 ![段描述符](records/段描述符格式.png)
 &emsp;在平坦模式(现在都是)下段基址都是0，G位表示段界限粒度，就是1B还是4KB，G==1表示4KB，此时16位段界限`2^16 * 4KB=4GB`,每个段享受的空间都是4GB(整个内存大小)，由虚拟地址空间区分保护不同的进程，数据。有了GDT，段寄存器里面存的就不是段基址，而是叫做选择子了，用来选择段描述符:
 ![选择子](records/选择子结构.png)
 </font>

<font size="2">&emsp;关于页表的初步创建也在loader里面。记录一下关于分页机制的设计。

![分页机制](records/二级页表占用内存示意.png)

见`src/include/boot.inc`的`PAGE_DIR_TABLE_POS`定义0x100000, 刚好是出低端1MB, 这是设计的页目录项的起始地址，操作系统会将页目录表的基地址加载到特定的控制寄存器中，不用担心寻找的问题。接下来会有很巧妙的设计!

![页目录项和页表项](records/页目录项和页表项.png)

可以看到页目录表和页表都是4B，页目录表一般只有是一页, 毕竟`4KB/4B=1K=1024=2^10`个页表，每个页页表中有2^10个页目录项，一个页目录项代表一页，那么`2^10 * 2^10 * 4KB = 4GB`, 足够了。让页目录表和页表紧凑(非必要),第一个页表地址就是0x10100。将页目录项0和0xc00都存为第一个页表的位置，原因是第一个页表存有2^10 * 4KB = 4MB内存，低端的1MB内存是在第一个页里面。0xc00指向的页是`3GB~4GB`内存，之后打算将这部分作为系统的内存，参考的linux，将这部分用作内核的内存空间，所以将3GB以上的这一页也映射为低端4MB内存.并且页目录项的最后一个目录项的地址是谁呢？是这个页目录项本身的物理地址。这个是为了之后用虚拟地址时能用到。
</font>

 <font size="2">&emsp;所以总结一下loader干了什么：构建GDT和里面的描述符, 三步骤开启保护模式，创建页目录项PDE和页表PTE, 在保护模式里(就是[bits 32] 然后下面的代码...)把内核代码从磁盘加载到内存, 然后jmp到内核入口地址。</font>

 <font size="2">&emsp;然后就是咱们的内核部分，要实现很多部分，首先是如何打印一个字符串？我记得刷过一个哈工大老师讲连接器和加载器时，问过一个问题，如何写一个最小的打印`hello world`的程序？其实很简单，调用库函数肯定不行，因为那样会增加很多前后处理的过程指令。所以最简单的就是汇编一个指令将字符写到显存部分即可，看实模式内存布局应该也能明白。不过显卡还提供了一些端口(就是外设提供的寄存器用于数据传输，操作某个设备)进行操作外设，我们可以操作这些端口打印字符，封住这样的打印字符函数，然后进而封装打印字符串和打印整数，这是这几个函数实现的原理。</font>

 <font size="2">&emsp;记录一下中断。先记录一下感觉没必要记录几个概念，外部中断是指来自cpu外部的中断，外部中断源必须是某个硬件，所以又称为硬件中断，比如网卡收到数据后发起的中断, cpu提供两根信号线区分外部中断的类型: INTR和NMI。 由于INTR的中断不影响系统运行，所以叫可屏蔽中断。NMI线过来的那些中断是灾难性的，无法屏蔽，所以其实即使eflags的IF设置关中断也不能阻挡。

 ![外部中断类型](records/外部中断类型.png)

&emsp;内部中断分为软中断和异常，软中断是指软件主动发起的中断， 比如`int 8位立即数`
常用的系统调用, 异常指cpu运行时错误，兜不住了，比如除以0， 所以像NMI一样，无法被屏蔽。

&emsp;中断向量就是一个中断的编号，可以看`records/异常与中断.png`这个表, 其中`0~31`系统保留，用于处理自己内部的中断，异常什么的。32以上可以自己分配处理外部设备的中断。类比GDT, 这里也有个中断描述符表的概念，里面存放着任务门描述符，中断，门描述符，陷阱门描述符，调用门描述符。详细还要看`p305`, 但是总之就是用8B指向一段处理程序的地址,中断描述符表的地址存放在IDTR(Interrupt Descriptor Table Register)。所以中断过程: 外部设备发出中断，由中断控制器(书中用的是Intel 8259A)接收中断，中断控制器经过根据优先级裁决出执行哪个中断，把中断向量号发给cpu，cpu根据中断向量号(中断描述符的索引)找到对应的门描述符，进而找到对应的处理程序, 这一段是CPU内部的中断处理机制自动完成，我们做的是维护了一个中断门描述符数组和里面自己写的中断处理函数，将这个数组地址写入了idtr，cpu根据中断向量号找到对应的中断门描述符，然后找到并对应的中断函数。所以初始化中断描述符表->异常名初始化并注册通常的中断处理函数->初始化8259A->idt表地址写入idtr。

**&emsp;但是这里是不是应该有个特权级的概念，其实在GDT的DPL字段就开始有特权级概念了，比较复杂, 我看得也很迷糊，不过总之需要了解DPL, RPL, CPL的关系，切换段的时候要判断特权级。另外切换处理程序是需要保存上下文环境的，就是将相关寄存器内容备份到栈中(可以看一下汇编指令`pushad`)**, 还是试着概述一下吧，以后再修正，段描述符中有两位DPL(Descriptor Privilege Level), 段选择子中的叫RPL(Request Privilege Level), 均占两位, 表示级别由高到低`0~4`, CPL叫Current Privilege Level存在于cs中, 代表着当前执行的段的特权级, 所以说DPL就是未来的CPL, 访问某个段的时候，os会构建选择子去访问，然后判断特权级关系。DPL中还有一位S标记段是否是系统段, 系统段(硬件所需的结构，各种门结构，调用门，任务门等), 软件所需的都是非系统段。下面讨论非系统段
，区分代码段和数据段，段有两个概念:1.一致性代码: 操作系统拿出来被共享的代码段,可以被低特权级的用户**直接调用**访问的代码。通常这些共享代码，是不访问受保护的资源和某些类型异常处理。比如一些数学计算函数库,为纯粹的数学运算计算。2.非一致性代码:为了避免低特权级的访问而被操作系统保护起来的系统代码。是由段描述符中4位type中的一位标记是否是一致性代码。然后再一个概念: 是否通过调用门的跳转？像我们平时jmp或者call直接跳转到另一个label, 然后就到目标代码的地址执行代码了。通过门跳转就是通过那些中断门描述符，任务门描述符，调用门描述符之类的结构(存储着段选择子和段偏移), 再找到目标代码段，中间是通过这个门数据结构找到的目标代码段。然后不经过门结构的普通跳转是不会引起CPL的变化的。
一致性代码限制了仅仅允许低特权级访问高特权级代码，但是CPL不变，非一致性代码仅仅允许同级访问。
&emsp;即对于非一致性代码段，要求:数值上CPL=RPL=目标代码段DPL; 对于一致性代码段: 数值上CPL>=目标代码段DPL && RPL>=目标代码段DPL。对于受访者为数据段时:数值上CPL<=目标数据段DPL && RPL<= 目标数据段DPL
</font>然后就是线程的调度，关于内核级线程和用户级线程还是有必要说明的。内核级线程就是在内核中实现线程，然后程序员就能调用创建内核线程，时间片轮转的话，对于每个线程都是平等的，公平竞争cpu时间，所以线程多了，拿到的cpu时间也多，所以更快。但是关于用户级线程，在用户级实现线程的调度，使用回调函数实现这一过程，内核是感知不到的，对于内核就是一个线程在运行，所以它和内核级多个线程去多多争取cpu时间是不一样的，所以用户级线程是比不上内核级线程的。想起python，咱们大多都是用的cpython这个解释器，它有个全局锁，它的执行其实就是单线程的，尽管可以在python中创建多线程，但是对于内核就是单线程，这应该就是python效率低的一个重要原因吧。
</font>

<font size="2">&emsp;关于线程的实现是由时钟中断来进行调度的，这块挺复杂的，分为两部分，一部分是中断时的保护，另一部分是调度时的保护。中断时的保护就是所有寄存器，调度时根据ABI的规定，只需要保护esi, edi, ebx, ebp, 和esp(abi规定这四个寄存器+esp归主调函数所有，其余归被调函数)。实现这个功能其实也不难，就是定义PCB记录一个线程的相关信息(栈顶，虚拟地址，优先级，运行时间，状态和存于某个队列的标志之类), 然后维护相关队列，切换进程时间保护和恢复上下文环境即可。</font>

<font size="2">&emsp;关于输入输出系统，有3部分，锁，键盘驱动，缓冲区.锁就比较简单了, 两个结构体，一个信号量(等待队列和资源数),一个锁结构(持有者，信号量，持有次数),关于持有次数是为了应对自己多次调用，多次释放的问题，然后再加上中断开关的函数，封装成锁的获取与释放，一下子就出来了。关于键盘的处理，首先键盘输入的过程是键盘按下一个键，然后由键盘内部的编码器(书上举例的8048)，向主板的键盘控制器(书上举例的8042)发送一个扫描码(这个也分为按下的通码makecode和松起的断码breadcode), 然后交给相应的中断程序去处理，现在一般用的键盘扫描码是scan code set 2, 不过这个无所谓，因为有8042这个中间件, 它会将收到的扫描码转换为第一套编码(p458表10-1), 然后键盘中断处理程序读取键盘控制器8042的输出缓冲区进行处理，然后这部分和外部硬件打交道的事情一般就交给驱动去做，所以上面描述这套转换操作经过封装形成键盘驱动，又由于比如shell不是一个一个字符处理的，是有命令的这些多字符组成得到特殊序列，所以键盘驱动中增加了个环形缓冲区记录输入的字符。</font>


